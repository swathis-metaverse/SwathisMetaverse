import { AmbientLight, BoxGeometry, CubeTextureLoader, DirectionalLight, Mesh, MeshStandardMaterial, Object3D, PlaneGeometry, PointLight, RepeatWrapping, SphereGeometry } from 'three'
import three from '../../three'
import useCanvasTexture from '../../tools/canvasTexture'
import psrdnoise from '../../glsl/psrdnoise3.glsl'
import { colorScale } from '../../tools/color'

const defaultConfig = {
  colors: [0xffffff, 0x000000],
  minStroke: 0.5,
  maxStroke: 5,
  timeCoef: 0.0005,
  coordScale1: 5,
  coordScale2: 2,
  displacementScale: 0.1,
  mouseScale: 0.25,
  mouseLerp: 0.025
}

export default function (params) {
  const config = { ...defaultConfig, ...params }

  const canvasTexture = useCanvasTexture({ width: 1, height: 2048 })
  // canvasTexture.texture.rotation = Math.PI / 2
  // canvasTexture.texture.center.set(0.5, 0.5)
  canvasTexture.texture.wrapS = canvasTexture.texture.wrapT = RepeatWrapping
  canvasTexture.texture.repeat.set(1, 1)
  drawTexture()

  const geometry = new PlaneGeometry(1, 1, 256, 256)
  // const geometry = new SphereGeometry(1, 256, 256)

  const uniforms = {
    uTime: { value: 0 },
    uCoordScale1: { value: config.coordScale1 },
    uCoordScale2: { value: config.coordScale2 },
    uDisplacementScale: { value: config.displacementScale }
  }

  const path = 'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/'
  const format = '.jpg'
  const urls = [
    path + 'px' + format, path + 'nx' + format,
    path + 'py' + format, path + 'ny' + format,
    path + 'pz' + format, path + 'nz' + format
  ]
  // const path = 'https://threejs.org/examples/textures/cube/Bridge2/'
  // const format = '.jpg'
  // const urls = [
  //   path + 'posx' + format, path + 'negx' + format,
  //   path + 'posy' + format, path + 'negy' + format,
  //   path + 'posz' + format, path + 'negz' + format
  // ]
  const envMap = new CubeTextureLoader().load(urls)

  const material = new MeshStandardMaterial({
    // color: 0xffffff,
    map: canvasTexture.texture,
    // envMap,
    // envMapIntensity: 1,
    // metalness: 1,
    // roughness: 0.25,
    onBeforeCompile: shader => {
      Object.keys(uniforms).forEach(key => {
        shader.uniforms[key] = uniforms[key]
      })
      shader.vertexShader = `
        uniform float uTime;
        uniform float uCoordScale1;
        uniform float uCoordScale2;
        uniform float uDisplacementScale;
        ${psrdnoise}
      ` + shader.vertexShader
      shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', '')
      shader.vertexShader = shader.vertexShader.replace('#include <normal_vertex>', '')
      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `
        // vec3 p = vec3(0.0); vec3 grad;
        // float d = psrdnoise(position * uCoordScale, p, uTime, grad);
        // grad *= uCoordScale;
        // vec3 transformed = position + uDisplacementScale * d * normal;

        vec3 p = vec3(0.0); vec3 grad;
        float n = 0.5 * psrdnoise(position * uCoordScale1, p, uTime, grad);
        vec3 warped = position * uCoordScale2 + 0.05 * grad;
        n += 0.25 * psrdnoise(warped, p * uCoordScale2, uTime * uCoordScale2, grad);

        vec3 transformed = position + uDisplacementScale * n * normal;
        // vec3 transformed = position + uDisplacementScale * n * normalize(position);

        vec3 N_ = grad - dot(grad, normal) * normal;
        vNormal = normal - uDisplacementScale * N_;
        vNormal = normalMatrix * normalize(vNormal);
      `)
    }
  })

  const mesh = new Mesh(geometry, material)

  three({
    el: params.el,
    alpha: true,
    antialias: true,
    // init ({ renderer }) {
    // },
    // initCamera ({ camera }) {
    // },
    initScene ({ camera, scene }) {
      camera.fov = 10
      camera.updateProjectionMatrix()
      camera.position.set(0, -2.25, 0.75)
      camera.lookAt(0, 0.5, 0)

      // scene.background = envMap
      scene.add(new AmbientLight(0xaaaaaa))

      // const light = new DirectionalLight(0xffffff, 0.5)
      // light.position.set(0, 10, 50)
      // scene.add(light)
      // light.target.position.set(0, 0, 0)
      // scene.add(light.target)

      const light = new PointLight(0xffffff, 2)
      light.position.set(0, 5, 2)
      scene.add(light)

      scene.add(mesh)
    },
    afterResize ({ wWidth, wHeight }) {
      // mesh.scale.set(wWidth * 2, wHeight * 4, 1)
      // const max = Math.max(wWidth, wHeight)
      // mesh.scale.set(max, max, 1)
      // mesh.scale.set(max, max, max)
    },
    beforeRender ({ clock }) {
      // canvasTexture.texture.offset.y = (canvasTexture.texture.offset.y - 0.0004)
      // if (canvasTexture.texture.offset.y < 0) canvasTexture.texture.offset.y += 1
      canvasTexture.texture.offset.y = (canvasTexture.texture.offset.y + 0.0004)
      if (canvasTexture.texture.offset.y > 1) canvasTexture.texture.offset.y -= 1
      uniforms.uTime.value = clock.time * config.timeCoef
    },
    onPointerMove ({ position, nPosition, delta }) {
    },
    onPointerLeave () {
    }
  })

  return { config, uniforms, material, drawTexture }

  function drawTexture () {
    const ctx = canvasTexture.ctx
    const { width, height } = canvasTexture.canvas
    const cscale = colorScale(config.colors)

    let y = 0
    let dy
    while (y < height) {
      dy = config.minStroke + Math.random() * (config.maxStroke - config.minStroke)
      ctx.fillStyle = cscale.getColorAt(Math.random()).getStyle()
      ctx.beginPath()
      ctx.rect(0, y - 1, width, dy + 1)
      ctx.fill()
      ctx.closePath()

      y += dy
    }

    canvasTexture.texture.needsUpdate = true
  }
}
